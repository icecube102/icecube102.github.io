<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 큐브 코인 시뮬레이터</title>
    <!-- Tailwind CSS 로드 --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js (3D 라이브러리) 로드 --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Chart.js (그래프 라이브러리) 로드 --><script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* 'Inter' 폰트 및 기본 스타일 적용 */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* 전체 페이지 스크롤 방지 */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        
        /* 3D 캔버스 스타일 (renderer.domElement) */
        canvas {
            display: block;
        }
        
        /* 트랜잭션 내역 스크롤바 커스텀 */
        .history-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .history-scrollbar::-webkit-scrollbar-thumb {
            background-color: #93c5fd; /* bg-blue-300 */
            border-radius: 20px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex flex-col lg:flex-row w-full h-screen">

        <!-- 왼쪽: 3D 뷰어 및 현재 가격 --><div id="canvas-container" class="lg:w-1/2 w-full h-1/2 lg:h-full relative bg-black">
            <!-- 3D 캔버스가 여기에 마운트됨 (JS에서) --><!-- 현재 가격 표시 --><div class="absolute top-4 left-4 bg-black/50 backdrop-blur-sm p-4 rounded-lg shadow-xl z-20">
                <h2 class="text-sm font-semibold text-blue-300 uppercase">CUBE-KRW</h2>
                <div id="current-price" class="text-4xl font-bold text-white">100,000 KRW</div>
                <div id="price-change" class="text-lg font-medium text-gray-300">-</div>
            </div>

            <!-- 큐브 구매 오버레이 --><div id="cube-purchase-overlay" class="absolute inset-0 bg-black/70 backdrop-blur-sm flex flex-col justify-center items-center text-center p-4 z-10">
                <h3 class="text-2xl font-bold mb-2">3D 큐브 잠금 해제</h3>
                <p class="text-gray-300 mb-4">큐브의 실시간 3D 회전을 활성화하려면 10,000,000 KRW가 필요합니다.</p>
                <button id="buy-cube-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors shadow-lg">
                    10,000,000 KRW에 구매
                </button>
            </div>
        </div>

        <!-- 오른쪽: 대시보드 (자산, 매매, 뉴스, 거래 내역) --><div class="lg:w-1/2 w-full h-1/2 lg:h-full p-6 bg-gray-800 flex flex-col gap-4 overflow-y-auto history-scrollbar">

            <h1 class="text-3xl font-bold text-center text-white mb-2">큐브 코인 시뮬레이터</h1>

            <!-- 1. 내 자산 현황 --><div class="grid grid-cols-2 gap-4">
                <div class="bg-gray-700 p-4 rounded-lg shadow-lg">
                    <h3 class="text-sm font-semibold text-gray-300">보유 현금 (KRW)</h3>
                    <div id="user-cash" class="text-2xl font-bold text-blue-400">1,000,000</div>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg shadow-lg">
                    <h3 class="text-sm font-semibold text-gray-300">보유 큐브 (CUBE)</h3>
                    <div id="user-cubes" class="text-2xl font-bold text-purple-400">0</div>
                </div>
            </div>

            <!-- 2. 매수 / 매도 입력 --><div class="bg-gray-700 p-4 rounded-lg shadow-lg">
                <label for="amount-input" class="text-sm font-semibold text-gray-300">거래 수량 (CUBE)</label>
                <input type="number" id="amount-input" value="1" min="1" class="w-full bg-gray-800 text-white p-2 rounded mt-2 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div class="grid grid-cols-2 gap-4 mt-4">
                    <button id="buy-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold p-3 rounded-lg transition-colors shadow-lg">
                        매수
                    </button>
                    <button id="sell-button" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold p-3 rounded-lg transition-colors shadow-lg">
                        매도
                    </button>
                </div>
            </div>

            <!-- 3. 실시간 가격 차트 --><div class="bg-gray-700 p-4 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold mb-2 text-white">실시간 차트</h3>
                <div class="h-40">
                    <canvas id="price-chart"></canvas>
                </div>
            </div>

            <!-- 4. 실시간 뉴스 --><div class="bg-gray-700 p-4 rounded-lg shadow-lg flex-grow flex flex-col">
                <h3 class="text-lg font-semibold mb-2 text-white">실시간 큐브 뉴스</h3>
                <div id="news-feed" class="flex-grow h-24 overflow-y-auto history-scrollbar pr-2">
                    <div class="text-gray-400 text-sm">시뮬레이터가 시작되었습니다. 가격 변동을 기다립니다...</div>
                </div>
            </div>

            <!-- 5. 거래 내역 --><div class="bg-gray-700 p-4 rounded-lg shadow-lg flex-grow flex flex-col">
                <h3 class="text-lg font-semibold mb-2 text-white">거래 내역</h3>
                <div id="transaction-history" class="flex-grow h-32 overflow-y-auto history-scrollbar pr-2">
                    <!-- 거래 내역이 여기에 추가됩니다 --><div class="text-gray-400 text-sm text-center p-4">거래 내역이 없습니다.</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 알림 메시지 (에러 등) --><div id="notification" class="fixed bottom-6 right-6 bg-red-500 text-white p-4 rounded-lg shadow-xl transition-all duration-300 opacity-0 translate-y-10 z-50">
        메시지 내용
    </div>

    <script>
        // --- Firebase 인스턴스 (module 스크립트에서 채워짐) ---
        let db, auth, userId, appId;

        // --- Three.js 3D 큐브 설정 ---
        let scene, camera, renderer, cube, cubeMaterial, light; // cubeMaterial 추가

        function initThree() {
            const container = document.getElementById('canvas-container');
            if (!container) return;

            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 5;

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.prepend(renderer.domElement); // 오버레이 요소들 뒤에 렌더러 추가

            // 4. Geometry & Material (큐브)
            const geometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            cubeMaterial = new THREE.MeshStandardMaterial({ // cubeMaterial 전역 변수로 할당
                color: 0x60a5fa, // Tailwind blue-400
                metalness: 0.5,
                roughness: 0.1
            });
            cube = new THREE.Mesh(geometry, cubeMaterial);
            
            const wireframeGeometry = new THREE.EdgesGeometry(cube.geometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            cube.add(wireframe);

            scene.add(cube);

            // 5. Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // 6. 리사이즈 핸들러
            window.addEventListener('resize', onWindowResize, false);
            
            // 7. 애니메이션 시작
            animate();
        }

        // 큐브 회전 애니메이션
        function animate() {
            requestAnimationFrame(animate);
            if (isCubePurchased && cube) { // 큐브를 구매했을 때만 회전
                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;
            }
            if (renderer) {
                renderer.render(scene, camera); // 렌더링은 항상 수행
            }
        }

        // 브라우저 창 크기 조절 시 캔버스 크기 맞춤
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            if (container && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }
        
        // 큐브 색상 변경 함수
        function flashCubeColor(color) {
            if (!isCubePurchased || !cubeMaterial) return;

            const originalColor = cubeMaterial.color.getHex();
            cubeMaterial.color.set(color);

            setTimeout(() => {
                if (cubeMaterial) {
                    cubeMaterial.color.set(originalColor);
                }
            }, 500); // 0.5초 후 원래 색상으로 복귀
        }


        // --- 차트 설정 ---
        let chartInstance = null;
        let priceHistory = {
            labels: [],
            data: []
        };

        function initChart() {
            const ctx = document.getElementById('price-chart').getContext('2d');
            if (!ctx) return;
            
            // 차트 그라데이션
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            gradient.addColorStop(0, 'rgba(96, 165, 250, 0.5)'); // Tailwind blue-400
            gradient.addColorStop(1, 'rgba(96, 165, 250, 0)');

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: priceHistory.labels,
                    datasets: [{
                        label: 'CUBE 가격',
                        data: priceHistory.data,
                        borderColor: '#60a5fa', // blue-400
                        backgroundColor: gradient,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            ticks: {
                                color: '#9ca3af' // gray-400
                            },
                            grid: {
                                color: '#4b5563' // gray-600
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateChart() {
            const historyLimit = 20;
            const time = new Date().toLocaleTimeString('ko-KR').split(' ')[1] || new Date().toLocaleTimeString('ko-KR');
            
            priceHistory.labels.push(time);
            priceHistory.data.push(currentPrice);
            
            if (priceHistory.labels.length > historyLimit) {
                priceHistory.labels.shift();
                priceHistory.data.shift();
            }
            
            if (chartInstance) {
                chartInstance.data.labels = priceHistory.labels;
                chartInstance.data.datasets[0].data = priceHistory.data;
                chartInstance.update('none'); // 'none' for no animation
            }
        }


        // --- 시뮬레이터 로직 ---
        
        // 1. 상태 변수 (Firebase에서 덮어쓸 수 있도록 let으로 변경)
        let userCash = 1000000; // 100만원으로 시작
        let userCubes = 0;
        let currentPrice = 100000;
        let transactions = [];
        let lastPrice = 100000;
        let isCubePurchased = false; // 큐브 구매 여부

        // 2. DOM 요소 (window.onload에서 할당)
        let cashDisplay, cubesDisplay, priceDisplay, priceChangeDisplay, amountInput, 
            buyButton, sellButton, newsFeed, transactionHistory, notification, 
            buyCubeButton, cubeOverlay;

        // 뉴스 데이터베이스
        const positiveNews = [
            "[속보] 큐브 체인, 대형 테크 기업과 파트너십 체결!",
            "[호재] 기관 투자자, 큐브 코인 대량 매집 시작",
            "큐브 코인, 차세대 업데이트 '퀀텀' 성공적 테스트 완료",
            "정부, 블록체인 기술 장려... 큐브 코인 수혜 예상",
            "유명 인플루언서, '큐브 코인은 미래다' 발언 화제"
        ];
        const negativeNews = [
            "[속보] 큐브 코인, 치명적 보안 취약점 발견 루머",
            "[악재] 주요 거래소, 큐브 코인 상장 폐지 검토",
            "금리 인상 쇼크... 큐브 코인 등 위험 자산 급락",
            "큐브 코인 개발팀 핵심 인력 이탈설... 투자 심리 위축",
            "해커, 큐브 코인 거래소 공격... 대규모 자산 동결"
        ];
        const neutralNews = [
            "큐브 코인, 숨 고르기 장세... 안정적 횡보",
            "시장, 이번 주 큐브 코인 로드맵 발표 주시",
            "큐브 코인 거래량 소폭 감소... 관망세 짙어져"
        ];

        // 3. UI 업데이트 함수
        function updateUI() {
            if (!cashDisplay || !cubesDisplay || !priceDisplay || !priceChangeDisplay) return;
            
            cashDisplay.textContent = userCash.toLocaleString('ko-KR');
            cubesDisplay.textContent = userCubes.toLocaleString('ko-KR');
            priceDisplay.textContent = `${currentPrice.toLocaleString('ko-KR')} KRW`;
            
            const change = currentPrice - lastPrice;
            const changePercent = lastPrice > 0 ? ((change / lastPrice) * 100).toFixed(2) : 0;
            
            if (change > 0) {
                priceChangeDisplay.innerHTML = `<span class="text-green-500">▲ ${change.toLocaleString('ko-KR')} (+${changePercent}%)</span>`;
            } else if (change < 0) {
                priceChangeDisplay.innerHTML = `<span class="text-red-500">▼ ${Math.abs(change).toLocaleString('ko-KR')} (${changePercent}%)</span>`;
            } else {
                priceChangeDisplay.innerHTML = `<span class="text-gray-400">0 (0.00%)</span>`;
            }
        }

        // 거래 내역 업데이트
        function updateTransactionHistory() {
            if (!transactionHistory) return;
            
            if (transactions.length === 0) {
                transactionHistory.innerHTML = '<div class="text-gray-400 text-sm text-center p-4">거래 내역이 없습니다.</div>';
                return;
            }
            
            transactionHistory.innerHTML = ''; // 초기화
            // 최신 100개만 표시 (성능을 위해)
            transactions.slice(-100).forEach(tx => {
                const txElement = document.createElement('div');
                txElement.className = 'border-b border-gray-600 p-2 text-sm';
                
                const typeClass = tx.type === '매수' ? 'text-green-400' : 'text-red-400';
                const time = new Date(tx.timestamp).toLocaleTimeString('ko-KR');
                
                txElement.innerHTML = `
                    <div>
                        <span class="${typeClass} font-bold">[${tx.type}]</span> ${tx.amount.toLocaleString('ko-KR')} CUBE
                    </div>
                    <div class="text-xs text-gray-400">
                        체결가: ${tx.price.toLocaleString('ko-KR')} KRW | ${time}
                    </div>
                `;
                transactionHistory.prepend(txElement); // 최신 내역을 위로
            });
        }
        
        // 뉴스 생성
        function generateNews(changePercent) {
            if (!newsFeed) return;
            let news = '';
            // changePercent는 0.05 (5%)와 같은 실수
            if (changePercent > 0.05) { // 5% 이상 급등
                news = positiveNews[Math.floor(Math.random() * positiveNews.length)];
            } else if (changePercent < -0.05) { // 5% 이상 급락
                news = negativeNews[Math.floor(Math.random() * negativeNews.length)];
            } else if (Math.abs(changePercent) > 0.001 && Math.random() < 0.2) { // 20% 확률로 중립 뉴스
                news = neutralNews[Math.floor(Math.random() * neutralNews.length)];
            } else {
                return; // 뉴스 생성 안함
            }

            const newsElement = document.createElement('div');
            newsElement.className = 'border-b border-gray-600 p-2 text-sm text-blue-200';
            newsElement.textContent = news;
            
            if (newsFeed.children.length === 1 && newsFeed.children[0].textContent.includes('기다립니다')) {
                newsFeed.innerHTML = '';
            }
            
            newsFeed.prepend(newsElement);
            
            if (newsFeed.children.length > 10) {
                newsFeed.removeChild(newsFeed.lastChild);
            }
        }
        
        // 알림 표시
        function showNotification(message, isError = true) {
            if (!notification) return;
            notification.textContent = message;
            notification.classList.remove(isError ? 'bg-green-500' : 'bg-red-500');
            notification.classList.add(isError ? 'bg-red-500' : 'bg-green-500');
            
            notification.classList.remove('opacity-0', 'translate-y-10');
            notification.classList.add('opacity-100', 'translate-y-0');

            setTimeout(() => {
                notification.classList.remove('opacity-100', 'translate-y-0');
                notification.classList.add('opacity-0', 'translate-y-10');
            }, 3000);
        }

        // 4. 핵심 로직: 가격 변동 (새로운 로직)
        function getPriceChange() {
            let direction = Math.random() < 0.55 ? 1 : -1; // 55% 상승, 45% 하락
            let magnitudeRand = Math.random();
            let changePercent;

            if (magnitudeRand < 0.60) { // 60% (소량)
                changePercent = (Math.random() * 0.01) + 0.001; // 0.1% ~ 1.1%
            } else if (magnitudeRand < 0.90) { // 30% (중량)
                changePercent = (Math.random() * 0.04) + 0.011; // 1.1% ~ 5.1%
            } else { // 10% (대량)
                changePercent = (Math.random() * 0.1) + 0.051; // 5.1% ~ 15.1%
            }

            const priceChange = currentPrice * changePercent * direction;
            
            // 뉴스를 위한 퍼센트 값 (부호 포함)
            return { priceChange, changePercent: changePercent * direction };
        }

        function updatePrice() {
            lastPrice = currentPrice;
            
            const { priceChange, changePercent } = getPriceChange();
            
            currentPrice = Math.max(1000, currentPrice + priceChange); // 최소 가격 1,000 KRW
            currentPrice = Math.round(currentPrice); // 정수로 반올림
            
            updateUI();
            generateNews(changePercent);
            updateChart(); // 차트 업데이트

            // 큐브 색상 변경 로직
            if (changePercent > 0) {
                flashCubeColor(0x00ff00); // 초록색
            } else if (changePercent < 0) {
                flashCubeColor(0xff0000); // 빨간색
            }
        }

        // 5. 이벤트 리스너
        function getAmount() {
            if (!amountInput) return 0;
            const amount = parseInt(amountInput.value, 10);
            if (isNaN(amount) || amount <= 0) {
                showNotification('유효한 수량을 입력하세요.', true);
                return 0;
            }
            return amount;
        }

        // --- Firebase 저장 함수 ---
        function saveGameState() {
            if (!db || !userId || !appId) {
                console.log("Firebase not ready, skipping save.");
                return; // Firebase 준비 전이면 저장 스킵
            }
            const gameState = {
                userCash: userCash,
                userCubes: userCubes,
                transactions: transactions,
                isCubePurchased: isCubePurchased
            };

            // Firestore는 import/export를 통해 모듈 스크립트의 함수를 사용해야 합니다.
            // 여기서는 module 스크립트에서 setDoc을 가져와 window에 할당하는 트릭을 씁니다.
            if (window.setDoc && window.doc) {
                const docRef = window.doc(db, "artifacts", appId, "users", userId, "simulator_state", "game_data");
                window.setDoc(docRef, gameState).catch(e => console.error("Error saving game state: ", e));
            }
        }


        // 6. 초기화 및 시작
        window.onload = () => {
            // DOM 요소 할당
            cashDisplay = document.getElementById('user-cash');
            cubesDisplay = document.getElementById('user-cubes');
            priceDisplay = document.getElementById('current-price');
            priceChangeDisplay = document.getElementById('price-change');
            amountInput = document.getElementById('amount-input');
            buyButton = document.getElementById('buy-button');
            sellButton = document.getElementById('sell-button');
            newsFeed = document.getElementById('news-feed');
            transactionHistory = document.getElementById('transaction-history');
            notification = document.getElementById('notification');
            buyCubeButton = document.getElementById('buy-cube-button');
            cubeOverlay = document.getElementById('cube-purchase-overlay');

            // 이벤트 리스너 할당
            buyButton.addEventListener('click', () => {
                const amount = getAmount();
                if (amount === 0) return;

                const totalCost = currentPrice * amount;
                if (userCash >= totalCost) {
                    userCash -= totalCost;
                    userCubes += amount;
                    
                    const tx = { type: '매수', amount: amount, price: currentPrice, timestamp: Date.now() };
                    transactions.push(tx);
                    
                    updateUI();
                    updateTransactionHistory();
                    showNotification(`${amount.toLocaleString('ko-KR')} CUBE 매수 완료!`, false);
                    saveGameState(); // 저장
                } else {
                    showNotification('보유 현금이 부족합니다.', true);
                }
            });

            sellButton.addEventListener('click', () => {
                const amount = getAmount();
                if (amount === 0) return;

                if (userCubes >= amount) {
                    userCash += (currentPrice * amount);
                    userCubes -= amount;
                    
                    const tx = { type: '매도', amount: amount, price: currentPrice, timestamp: Date.now() };
                    transactions.push(tx);
                    
                    updateUI();
                    updateTransactionHistory();
                    showNotification(`${amount.toLocaleString('ko-KR')} CUBE 매도 완료!`, false);
                    saveGameState(); // 저장
                } else {
                    showNotification('보유한 큐브 코인이 부족합니다.', true);
                }
            });

            buyCubeButton.addEventListener('click', () => {
                const cubePrice = 10000000;
                if (userCash >= cubePrice) {
                    userCash -= cubePrice;
                    isCubePurchased = true;
                    cubeOverlay.style.display = 'none'; // 오버레이 숨기기
                    updateUI(); // 현금 UI 업데이트
                    showNotification('3D 큐브 회전이 활성화되었습니다!', false);
                    saveGameState(); // 저장
                } else {
                    showNotification('3D 큐브를 구매할 현금이 부족합니다. (필요: 1천만 KRW)', true);
                }
            });

            // 큐브 구매 여부 확인 (Firebase 로드 후에도 UI가 업데이트되도록)
            if (isCubePurchased) {
                cubeOverlay.style.display = 'none';
            }

            initThree(); // 3D 씬 초기화
            initChart(); // 차트 초기화
            updateUI(); // UI 초기화 (기본값으로)
            updateTransactionHistory(); // 거래 내역 초기화 (기본값으로)
            
            // 3초마다 가격 업데이트
            setInterval(updatePrice, 3000);
        };
        
    </script>

    <!-- Firebase SDK 모듈 스크립트 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestore 함수를 전역 스코프로 노출 (메인 스크립트에서 사용)
        window.doc = doc;
        window.setDoc = setDoc;

        // Firebase 설정
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appIdGlobal = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        try {
            const app = initializeApp(firebaseConfig);
            const authGlobal = getAuth(app);
            const dbGlobal = getFirestore(app);
            setLogLevel('Debug'); // Firestore 로그 활성화

            // 전역 변수에 할당
            window.db = dbGlobal;
            window.auth = authGlobal;
            window.appId = appIdGlobal;

            onAuthStateChanged(authGlobal, async (user) => {
                if (user) {
                    console.log("Firebase user signed in:", user.uid);
                    window.userId = user.uid; // 전역 userId 설정

                    // 데이터 로드 시도
                    const docRef = doc(dbGlobal, "artifacts", appIdGlobal, "users", user.uid, "simulator_state", "game_data");
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        // 데이터가 있으면 로드
                        console.log("Loading saved data...");
                        const data = docSnap.data();
                        window.userCash = data.userCash;
                        window.userCubes = data.userCubes;
                        window.transactions = data.transactions || [];
                        window.isCubePurchased = data.isCubePurchased;
                        
                        // UI 즉시 업데이트
                        window.updateUI();
                        window.updateTransactionHistory();
                        if (window.isCubePurchased) {
                            const overlay = document.getElementById('cube-purchase-overlay');
                            if (overlay) overlay.style.display = 'none';
                        }

                    } else {
                        // 데이터가 없으면 (최초 방문) 현재 기본값으로 저장
                        console.log("No data found. Saving initial state.");
                        window.saveGameState(); 
                    }

                } else {
                    // 로그인되지 않았으면 로그인 시도
                    console.log("No user. Attempting sign in...");
                    if (initialAuthToken) {
                        await signInWithCustomToken(authGlobal, initialAuthToken);
                    } else {
                        await signInAnonymously(authGlobal);
                    }
                }
            });

        } catch (e) {
            console.error("Firebase initialization failed: ", e);
            showNotification("데이터베이스 연결에 실패했습니다.", true);
        }

    </script>
</body>
</html>
